# 実直にSIMする解法

## 方針

* 隣り合う数値の差が最大になるだから、並び変える際に常に差分が最大になるようにおいていく。
* 与えられた数列を順番に並び変えて`A_ordered = collection.deque()`で保持する
  * 頭＝最小値とお尻＝最大値の取り出し処理が早くで容易



## 実装

* 最初に最大値と最小値を抜き出し並べた`res_list = collection.deque()`を用意する
* その差の絶対値を暫定解`res`とする
* `res_list`の頭とお尻と`A_ordered`の頭とお尻（残りの最大と最小）をそれぞれ4通りの組み合わせで比較して、差の絶対値が最大になるように、`res_list`に値を並べていく。
* 並べ替えと同時に`res`を積算していく

# 数式から導かれる解法

## 方針


* 解の数列を$|a_i|$とすると、小、大、小、大、と並ぶので、解の求め方は以下となる
  * $(a_2 -a_1) + (a_2 - a_3) + (a_4 -a_3) + ... +(a_i - a_{i-1})もしくは(a_{i-1} - a_i)$　…式１
  * $-a_1 + 2a_2 -2a_3 + .... +a_iもしくは-a_i$　…式２
* よって与えられた数列の大きいものと、小さいものから順に係数2へ割りあててゆき、最後に残った二つ（真ん中の二つ）の値を$a_1$と$a_i$に当てる。
* 上記割り当てが決まれば、式２を計算するのみ。
* 数学的な考察が出来れば実装は簡単
* 差が最大（最小に）になる数列の問題は多く出るので、解の数学的な考察は覚えておいた方がよさそう。